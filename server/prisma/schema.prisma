generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String  @id @default(uuid())
  clerkUserId String  @unique
  email       String  @unique
  name        String?
  imageUrl    String?

  industry    String?
  subIndustry String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bio        String?
  experience Int?
  skills     String[]

  industryInsight IndustryInsight? @relation(fields: [industry, subIndustry], references: [industry, subIndustry])

  assessments Assessment[]
  coverLetter CoverLetter[]
  resume      Resume?
}

model Assessment {
  id             String   @id @default(cuid())
  userId         String
  quizScore      Float
  questions      Json[]
  category       String
  improvementTip String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

model Resume {
  id     String @id @default(cuid())
  userId String @unique

  // Structured resume data
  personalInfo   Json?
  summary        String?
  experience     Json[]
  education      Json[]
  skills         String[]
  certifications String[]
  languages      String[]

  // Legacy field for backward compatibility
  content String?

  atsScore   Float?
  feedback   String?
  shareToken String? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model CoverLetter {
  id             String   @id @default(cuid())
  userId         String
  content        String
  jobDescription String?
  companyName    String
  jobTitle       String
  status         String   @default("draft")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

model IndustryInsight {
  id String @id @default(cuid())

  industry    String
  subIndustry String

  salaryRanges      Json[]
  growthRate        Float
  demandLevel       String
  topSkills         String[]
  marketOutlook     String
  keyTrends         String[]
  recommendedSkills String[]

  lastUpdated DateTime @default(now())
  nextUpdate  DateTime

  users User[]

  @@unique([industry, subIndustry])
  @@index([industry])
}

// ===== AI JOB MATCHER MODELS =====

// Resume profiles for job matching (separate from main Resume model)
model ResumeProfile {
  id        String   @id @default(uuid())
  userId    String? // Optional: can link to User model
  title     String // e.g., "Senior Backend Developer Resume"
  rawText   String   @db.Text
  fileName  String?
  fileSize  Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  recommendations JobRecommendation[]

  @@index([userId])
  @@index([createdAt])
  @@map("resume_profiles")
}

// Job postings fetched from external APIs
model JobPosting {
  id          String    @id @default(uuid())
  externalId  String // Job ID from the source API
  source      String // e.g., "jobicy", "adzuna", "remoteok"
  title       String
  company     String
  location    String?
  url         String
  description String    @db.Text
  salary      String?
  jobType     String? // e.g., "full-time", "contract", "remote"
  tags        String[] // Skills/technologies
  postedAt    DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  recommendations JobRecommendation[]

  @@unique([externalId, source])
  @@index([source])
  @@index([createdAt])
  @@index([jobType])
  @@map("job_postings")
}

// AI-powered job recommendations with match scores
model JobRecommendation {
  id            String   @id @default(uuid())
  resumeId      String
  jobId         String
  matchScore    Float // 0-100 similarity score
  mainReason    String   @db.Text // AI-generated explanation
  skillsMatched String[] // Skills from resume found in job
  skillsMissing String[] // Skills in job not in resume
  aiMetadata    Json? // Store full AI response if needed
  createdAt     DateTime @default(now())

  resume ResumeProfile @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  job    JobPosting    @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([resumeId, jobId])
  @@index([resumeId, createdAt])
  @@index([matchScore])
  @@map("job_recommendations")
}
